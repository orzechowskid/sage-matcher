{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../../src/hooks/useAsyncDebounce.js","../../src/hooks/useFormContext.js","../../src/hooks/useFormElement.js","../../src/utils.js","../../src/hooks/useForm.js","../../src/hooks/useFieldScope.js","../../src/hooks/useField.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js","../node_modules/regenerator-runtime/runtime.js"],"names":["asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","_asyncToGenerator","fn","self","this","args","arguments","apply","err","undefined","useAsyncDebounce","defaultFn","defaultWait","debounceRef","React","debounce","a","wait","clearTimeout","setTimeout","formContext","FormContextProvider","children","useFormContext","manualFormContext","formApi","Error","useFormElement","contextValue","FormRef","FormApiRef","Form","noFormElement","rest","handleSubmit","isSubmitting","debugForm","current","onSubmit","disabled","style","margin","fontWeight","JSON","safeStringifyReplace","set","Array","getBy","obj","path","makePathArray","setBy","updater","doSet","parent","prefix","getFieldID","str","reFindNumbers0","reFindNumbers1","reFindNumbers2","reFindNumbers3","reFindMultiplePeriods","d","parseInt","someObject","found","loopObject","callback","Object","defaultDefaultValue","makeState","decor","meta","isTouched","isSubmitted","submissionAttempts","__fieldMeta","useForm","defaultValues","validate","validatePristine","values","setState","shouldResubmit","setShouldResubmit","apiRef","metaRef","__fieldMetaRefsRef","fieldsAreValidating","field","fieldsAreValid","isValid","canSubmit","api","reset","e","needsResubmit","fieldValidationPromises","fieldMeta","fieldInstance","old","setMeta","runValidation","isValidating","id","checkLatest","doValidation","getFieldValue","getFieldMeta","fieldID","__getFieldMetaRef","instanceRefs","setFieldMeta","newFieldMeta","setFieldValue","fieldInstances","newValue","instance","__getFieldInstances","__metaRef","pushFieldValue","insertFieldValue","i","removeFieldValue","swapFieldValues","old1","old2","setValues","__fieldMetaRefs","useFieldScope","FieldScopeRef","FieldScopeApiRef","Field","uid","methodMap","defaultDefaultMeta","useField","defaultValue","defaultIsTouched","defaultError","defaultMeta","filterValue","formApiRef","fieldApiRef","instanceIDRef","instanceID","fieldPrefix","fieldName","preValue","preMeta","fieldApi","form","setValue","pushValue","insertValue","removeValue","swapValues","doValidate","getInputProps","onChange","onBlur","FieldScope","console","_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","sourceKeys","keys","length","indexOf","getOwnPropertySymbols","sourceSymbolKeys","prototype","propertyIsEnumerable","call","module","exports","runtime","Op","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","makeInvokeMethod","state","invoke","method","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","enqueue","callInvokeWithMethodAndArg","result","__await","unwrapped","TypeError","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","iterable","iteratorMethod","isNaN","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","iter","toString","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function"],"mappings":"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","file":"static/js/0.8aacfaa0.chunk.js","sourcesContent":["function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","import React from 'react'\n\nexport default function useAsyncDebounce(defaultFn, defaultWait = 0) {\n  const debounceRef = React.useRef({})\n  debounceRef.current.defaultFn = defaultFn\n  debounceRef.current.defaultWait = defaultWait\n\n  const debounce = React.useCallback(\n    async (\n      fn = debounceRef.current.defaultFn,\n      wait = debounceRef.current.defaultWait\n    ) => {\n      if (!debounceRef.current.promise) {\n        debounceRef.current.promise = new Promise(resolve => {\n          debounceRef.current.resolve = resolve\n        })\n      }\n\n      if (debounceRef.current.timeout) {\n        clearTimeout(debounceRef.current.timeout)\n      }\n\n      debounceRef.current.timeout = setTimeout(async () => {\n        delete debounceRef.current.timeout\n        try {\n          debounceRef.current.resolve(await fn())\n        } catch (err) {\n          debounceRef.current.reject(err)\n        } finally {\n          delete debounceRef.current.promise\n        }\n      }, wait)\n\n      return debounceRef.current.promise\n    },\n    []\n  )\n\n  return debounce\n}\n","import React from 'react'\n//\n\nconst formContext = React.createContext()\n\nexport function FormContextProvider({ value, children }) {\n  return <formContext.Provider value={value}>{children}</formContext.Provider>\n}\n\nexport default function useFormContext(manualFormContext) {\n  let formApi = React.useContext(formContext)\n\n  if (manualFormContext) {\n    return manualFormContext\n  }\n\n  if (!formApi) {\n    throw new Error(`You are trying to use the form API outside of a form!`)\n  }\n\n  return formApi\n}\n","import React from 'react'\n//\n\nimport { FormContextProvider } from './useFormContext'\n\nexport default function useFormElement(contextValue) {\n  const FormRef = React.useRef()\n  const FormApiRef = React.useRef()\n\n  FormApiRef.current = contextValue\n\n  // Create a new form element\n  if (!FormRef.current) {\n    FormRef.current = function Form({ children, noFormElement, ...rest }) {\n      const {\n        handleSubmit,\n        meta: { isSubmitting },\n        debugForm,\n      } = FormApiRef.current\n\n      return (\n        <FormContextProvider value={FormApiRef.current}>\n          {noFormElement ? (\n            children\n          ) : (\n            <form onSubmit={handleSubmit} disabled={isSubmitting} {...rest}>\n              {children}\n              {debugForm ? (\n                <div\n                  style={{\n                    margin: '2rem 0',\n                  }}\n                >\n                  <div\n                    style={{\n                      fontWeight: 'bolder',\n                    }}\n                  >\n                    Form State\n                  </div>\n                  <pre>\n                    <code>\n                      {JSON.stringify(\n                        { ...FormApiRef.current, formContext: undefined },\n                        safeStringifyReplace(new Set()),\n                        2\n                      )}\n                    </code>\n                  </pre>\n                </div>\n              ) : null}\n            </form>\n          )}\n        </FormContextProvider>\n      )\n    }\n  }\n\n  // Return the form element\n  return FormRef.current\n}\n\nfunction safeStringifyReplace(set) {\n  return (key, value) => {\n    if (typeof value === 'object' || Array.isArray(value)) {\n      if (set.has(value)) {\n        return '(circular value)'\n      }\n      set.add(value)\n    }\n    return typeof value === 'function' ? undefined : value\n  }\n}\n","export function splitFormProps({\n  field,\n  defaultValue,\n  defaultIsTouched,\n  defaultError,\n  defaultMeta,\n  validatePristine,\n  validate,\n  onSubmit,\n  defaultValues,\n  filterValue,\n  debugForm,\n  ...rest\n}) {\n  return [\n    field,\n    {\n      defaultValue,\n      defaultIsTouched,\n      defaultError,\n      defaultMeta,\n      validatePristine,\n      validate,\n      onSubmit,\n      defaultValues,\n      filterValue,\n      debugForm,\n    },\n    rest,\n  ]\n}\n\n// Utils\n\nexport function getBy(obj, path) {\n  if (!path) {\n    throw new Error('A path string is required to use getBy')\n  }\n  const pathArray = makePathArray(path)\n  const pathObj = pathArray\n  return pathObj.reduce((current, pathPart) => {\n    if (typeof current !== 'undefined') {\n      return current[pathPart]\n    }\n    return undefined\n  }, obj)\n}\n\nexport function setBy(obj, path, updater) {\n  path = makePathArray(path)\n\n  function doSet(parent) {\n    if (!path.length) {\n      return typeof updater === 'function' ? updater(parent) : updater\n    }\n\n    const key = path.shift()\n\n    if (typeof key === 'string') {\n      if (typeof parent === 'object') {\n        return {\n          ...parent,\n          [key]: doSet(parent[key]),\n        }\n      }\n      return {\n        [key]: doSet(),\n      }\n    }\n\n    if (typeof key === 'number') {\n      if (Array.isArray(parent)) {\n        const prefix = parent.slice(0, key)\n        return [\n          ...(prefix.length ? prefix : new Array(key)),\n          doSet(parent[key]),\n          ...parent.slice(key + 1),\n        ]\n      }\n      return [...new Array(key), doSet()]\n    }\n\n    throw new Error('Uh oh!')\n  }\n\n  return doSet(obj)\n}\n\nexport function getFieldID(str) {\n  return makePathArray(str).join('_')\n}\n\nconst reFindNumbers0 = /^(\\d*)$/gm\nconst reFindNumbers1 = /\\.(\\d*)\\./gm\nconst reFindNumbers2 = /^(\\d*)\\./gm\nconst reFindNumbers3 = /\\.(\\d*$)/gm\nconst reFindMultiplePeriods = /\\.{2,}/gm\n\nfunction makePathArray(str) {\n  return str\n    .replace('[', '.')\n    .replace(']', '')\n    .replace(reFindNumbers0, '__int__$1')\n    .replace(reFindNumbers1, '.__int__$1.')\n    .replace(reFindNumbers2, '__int__$1.')\n    .replace(reFindNumbers3, '.__int__$1')\n    .replace(reFindMultiplePeriods, '.')\n    .split('.')\n    .map(d => {\n      if (d.indexOf('__int__') === 0) {\n        return parseInt(d.substring('__int__'.length), 10)\n      }\n      return d\n    })\n}\n\nfunction loopObject(obj, fn, callback) {\n  Object.keys(obj).forEach(key => {\n    callback(fn(obj[key], key), key)\n  })\n}\n\nexport function someObject(obj, fn) {\n  let found = false\n\n  loopObject(obj, fn, (result, key) => {\n    if (found) {\n      return\n    }\n    if (result) {\n      found = true\n    }\n  })\n\n  return found\n}\n","import React from 'react'\n//\nimport useAsyncDebounce from './useAsyncDebounce'\nimport useFormElement from './useFormElement'\nimport { someObject, getBy, setBy, getFieldID } from '../utils'\n\nconst defaultDefaultValue = {}\n\nfunction makeState(decor) {\n  return {\n    meta: {\n      isSubmitting: false,\n      isTouched: false,\n      isSubmitted: false,\n      submissionAttempts: 0,\n    },\n    __fieldMeta: {},\n    ...decor,\n  }\n}\n\nexport default function useForm({\n  onSubmit,\n  defaultValues = defaultDefaultValue,\n  validate,\n  validatePristine,\n  debugForm,\n} = {}) {\n  let [{ values, meta, __fieldMeta }, setState] = React.useState(() =>\n    makeState({\n      values: defaultValues,\n    })\n  )\n\n  const [shouldResubmit, setShouldResubmit] = React.useState(false)\n  const apiRef = React.useRef()\n  const metaRef = React.useRef({})\n  const __fieldMetaRefsRef = React.useRef({})\n\n  // Keep validate up to date with the latest version\n  metaRef.current.validate = validate\n\n  const fieldsAreValidating = someObject(\n    __fieldMeta,\n    field => field && field.isValidating\n  )\n  const fieldsAreValid = !someObject(__fieldMeta, field => field && field.error)\n\n  // Can we submit this form?\n  const isValid = !fieldsAreValidating && fieldsAreValid && !meta.error\n\n  const canSubmit = isValid && !meta.isValidating && !meta.isSubmitting\n\n  // Decorate form meta\n  meta = React.useMemo(\n    () => ({\n      ...meta,\n      fieldsAreValidating,\n      fieldsAreValid,\n      isValid,\n      canSubmit,\n    }),\n    [meta, fieldsAreValidating, fieldsAreValid, isValid, canSubmit]\n  )\n\n  // We want the apiRef to change every time state updates\n  const api = React.useMemo(\n    () => ({\n      values,\n      meta,\n      __fieldMeta,\n      debugForm,\n    }),\n    [debugForm, __fieldMeta, meta, values]\n  )\n  // Keep the apiRef up to date with the latest version of the api\n  apiRef.current = api\n\n  const reset = React.useCallback(() => {\n    setState(() =>\n      makeState({\n        values: defaultValues,\n      })\n    )\n  }, [defaultValues, setState])\n\n  // On submit\n  const handleSubmit = React.useCallback(async (e = {}) => {\n    if (e.persist) e.persist()\n    if (e.preventDefault) e.preventDefault()\n\n    // This lets sub-forms with form elements (despite them being invalid HTML)\n    // handle submissions without triggering parent forms\n    if (e.__handled) {\n      return\n    }\n    e.__handled = true\n\n    // Don't let invalid forms submit\n    if (!apiRef.current.meta.isValid) {\n      // If the form can't submit, let's trigger all of the fields\n      // to be touched. Thus, their validations will run\n      apiRef.current.setMeta({ isSubmitting: false })\n      return\n    }\n\n    apiRef.current.setMeta({ isSubmitting: true })\n\n    let needsResubmit = false\n\n    const fieldValidationPromises = []\n\n    Object.keys(apiRef.current.__fieldMetaRefs).forEach(key => {\n      const { current: fieldMeta } = apiRef.current.__fieldMetaRefs[key]\n      Object.keys(fieldMeta.instanceRefs).forEach(key => {\n        const { current: fieldInstance } = fieldMeta.instanceRefs[key]\n        // If any fields are not touched\n        if (!fieldInstance.meta.isTouched) {\n          // Mark them as touched\n          fieldInstance.setMeta({ isTouched: true })\n          // Likewise, if they need validation\n          if (fieldInstance.__validate) {\n            // Run their validation and keep track of the\n            // promise\n            fieldValidationPromises.push(fieldInstance.runValidation())\n          }\n        }\n      })\n    })\n\n    // If any validation needed to be run\n    if (fieldValidationPromises.length) {\n      // Mark for resubmission\n      needsResubmit = true\n    }\n\n    if (!apiRef.current.meta.isTouched) {\n      // Mark for resubmission\n      needsResubmit = true\n\n      // Mark the form as touched\n      apiRef.current.setMeta(old => ({\n        ...old,\n        isTouched: true,\n      }))\n    }\n\n    if (needsResubmit) {\n      // Wait for any field validations to complete\n      await Promise.all(fieldValidationPromises)\n      // Be sure to run validation for the form\n      // and wait for it to complete\n      await apiRef.current.runValidation()\n      // Then rerun the submission attempt\n      e.__handled = false\n      setShouldResubmit(e || true)\n      // Do not continue\n      return\n    }\n\n    apiRef.current.setMeta(old => ({\n      ...old,\n      // Submittion attempts mark the form as not submitted\n      isSubmitted: false,\n      // Count submission attempts\n      submissionAttempts: old.submissionAttempts + 1,\n    }))\n\n    try {\n      // Run the submit code\n      await apiRef.current.onSubmit(apiRef.current.values, apiRef.current)\n\n      apiRef.current.setMeta({ isSubmitted: true })\n    } catch (err) {\n      throw err\n    } finally {\n      apiRef.current.setMeta({ isSubmitting: false })\n    }\n  }, [])\n\n  // Create a debounce for this field hook instance (not all instances)\n  const debounce = useAsyncDebounce()\n\n  const setMeta = React.useCallback(\n    updater => {\n      setState(old => ({\n        ...old,\n        meta:\n          typeof updater === 'function'\n            ? updater(old.meta)\n            : { ...old.meta, ...updater },\n      }))\n    },\n    [setState]\n  )\n\n  const runValidation = React.useCallback(() => {\n    if (!metaRef.current.validate) {\n      return\n    }\n    apiRef.current.setMeta({ isValidating: true })\n\n    // Use the validationCount for all field instances to\n    // track freshness of the validation\n    const id = (metaRef.current.validationCount || 0) + 1\n    metaRef.current.validationCount = id\n\n    const checkLatest = () => id === metaRef.current.validationCount\n\n    if (!metaRef.current.validationPromise) {\n      metaRef.current.validationPromise = new Promise((resolve, reject) => {\n        metaRef.current.validationResolve = resolve\n        metaRef.current.validationReject = reject\n      })\n    }\n\n    const doValidation = async () => {\n      try {\n        const error = await metaRef.current.validate(\n          apiRef.current.values,\n          apiRef.current\n        )\n\n        if (checkLatest()) {\n          apiRef.current.setMeta({ isValidating: false })\n          if (typeof error !== 'undefined') {\n            if (error) {\n              if (typeof error === 'string') {\n                apiRef.current.setMeta({ error })\n              }\n            } else {\n              apiRef.current.setMeta({ error: null })\n            }\n          }\n          metaRef.current.validationResolve()\n        }\n      } catch (err) {\n        if (checkLatest()) {\n          metaRef.current.validationReject(err)\n        }\n      } finally {\n        delete metaRef.current.validationPromise\n      }\n    }\n\n    doValidation()\n\n    return metaRef.current.validationPromise\n  }, [])\n\n  const getFieldValue = React.useCallback(\n    field => getBy(apiRef.current.values, field),\n    []\n  )\n\n  const getFieldMeta = React.useCallback(field => {\n    const fieldID = getFieldID(field)\n    return apiRef.current.__fieldMeta[fieldID]\n  }, [])\n\n  const __getFieldMetaRef = React.useCallback(field => {\n    const fieldID = getFieldID(field)\n    if (!apiRef.current.__fieldMetaRefs[fieldID]) {\n      apiRef.current.__fieldMetaRefs[fieldID] = {\n        current: {\n          instanceRefs: {},\n        },\n      }\n    }\n    return apiRef.current.__fieldMetaRefs[fieldID]\n  }, [])\n\n  const setFieldMeta = React.useCallback(\n    (field, updater) => {\n      const fieldID = getFieldID(field)\n      setState(old => {\n        const newFieldMeta =\n          typeof updater === 'function'\n            ? updater(old.__fieldMeta[fieldID])\n            : { ...old.__fieldMeta[fieldID], ...updater }\n\n        return {\n          ...old,\n          // Any errors in fields should visually stop\n          // form.isSubmitting\n          meta:\n            newFieldMeta && newFieldMeta.error\n              ? {\n                  ...old.meta,\n                  isSubmitting: false,\n                }\n              : old.meta,\n          __fieldMeta: {\n            ...old.__fieldMeta,\n            [fieldID]: newFieldMeta,\n          },\n        }\n      })\n    },\n    [setState]\n  )\n\n  const setFieldValue = React.useCallback(\n    (field, updater, { isTouched = true } = {}) => {\n      const fieldInstances = apiRef.current.__getFieldInstances(field)\n\n      setState(old => {\n        let newValue =\n          typeof updater === 'function'\n            ? updater(getBy(old.values, field))\n            : updater\n\n        fieldInstances.forEach(instance => {\n          if (instance.current.__filterValue) {\n            newValue = instance.current.__filterValue(newValue, apiRef.current)\n          }\n        })\n\n        return {\n          ...old,\n          values: setBy(old.values, field, newValue),\n        }\n      })\n      if (isTouched) {\n        apiRef.current.setFieldMeta(field, {\n          isTouched: true,\n        })\n        apiRef.current.setMeta({ isTouched: true })\n      }\n    },\n    [setState]\n  )\n\n  const __getFieldInstances = React.useCallback(field => {\n    const __metaRef = apiRef.current.__getFieldMetaRef(field)\n    return Object.keys(__metaRef.current.instanceRefs).map(\n      key => __metaRef.current.instanceRefs[key]\n    )\n  }, [])\n\n  const pushFieldValue = React.useCallback((field, value, options) => {\n    apiRef.current.setFieldValue(\n      field,\n      old => {\n        return [...(Array.isArray(old) ? old : []), value]\n      },\n      options\n    )\n  }, [])\n\n  const insertFieldValue = React.useCallback((field, index, value, options) => {\n    apiRef.current.setFieldValue(\n      field,\n      old => {\n        if (Array.isArray(old)) {\n          return old.map((d, i) => (i === index ? value : d))\n        } else {\n          throw Error(\n            `Cannot insert a field value into a non-array field. Check that this field's existing value is an array: ${field}.`\n          )\n        }\n      },\n      options\n    )\n  }, [])\n\n  const removeFieldValue = React.useCallback((field, index, options) => {\n    apiRef.current.setFieldValue(\n      field,\n      old => {\n        if (Array.isArray(old)) {\n          return old.filter((d, i) => i !== index)\n        } else {\n          throw Error(\n            `Cannot remove a field value from a non-array field. Check that this field's existing value is an array: ${field}.`\n          )\n        }\n      },\n      options\n    )\n  }, [])\n\n  const swapFieldValues = React.useCallback(\n    (path, index1, index2) => {\n      setState(old => {\n        const old1 = getBy(old.values, [path, index1])\n        const old2 = getBy(old.values, [path, index2])\n\n        let values = setBy(old.values, [path, index1], old2)\n        values = setBy(values, [path, index2], old1)\n\n        return {\n          ...old,\n          values,\n        }\n      })\n    },\n    [setState]\n  )\n\n  const setValues = React.useCallback(\n    values => {\n      setState(old => ({\n        ...old,\n        values: values,\n      }))\n    },\n    [setState]\n  )\n\n  // Create the Form element if necessary\n  const Form = useFormElement(api)\n\n  Object.assign(api, {\n    __fieldMetaRefs: __fieldMetaRefsRef.current,\n    onSubmit,\n    reset,\n    handleSubmit,\n    debounce,\n    setMeta,\n    runValidation,\n    getFieldValue,\n    getFieldMeta,\n    __getFieldMetaRef,\n    setFieldMeta,\n    setFieldValue,\n    __getFieldInstances,\n    pushFieldValue,\n    insertFieldValue,\n    removeFieldValue,\n    swapFieldValues,\n    setValues,\n    Form,\n    formContext: api,\n  })\n\n  // If shouldResubmit is true, do yo thang\n  React.useEffect(() => {\n    if (shouldResubmit) {\n      handleSubmit(shouldResubmit)\n      setShouldResubmit(false)\n    }\n  }, [handleSubmit, shouldResubmit])\n\n  // When the form gets dirty and when the value changes\n  // validate\n  React.useEffect(() => {\n    if (!validatePristine && !meta.isTouched) {\n      return\n    }\n\n    apiRef.current.runValidation(values)\n  }, [meta.isTouched, validatePristine, values])\n\n  // When defaultValues update, set them\n  React.useEffect(() => {\n    if (defaultValues !== apiRef.current.values) {\n      setState(old => ({\n        ...old,\n        values: defaultValues,\n      }))\n    }\n  }, [defaultValues, setState])\n\n  // Return the root form and the Form component to the hook user\n  return apiRef.current\n}\n","import React from 'react'\n//\n\nimport { FormContextProvider } from './useFormContext'\n\nexport default function useFieldScope(contextValue) {\n  const FieldScopeRef = React.useRef()\n  const FieldScopeApiRef = React.useRef()\n\n  FieldScopeApiRef.current = contextValue\n\n  // Create a new form element\n  if (!FieldScopeRef.current) {\n    FieldScopeRef.current = function Field({ children }) {\n      return (\n        <FormContextProvider value={FieldScopeApiRef.current}>\n          {children}\n        </FormContextProvider>\n      )\n    }\n  }\n\n  return FieldScopeRef.current\n}\n","import React from 'react'\n//\nimport useAsyncDebounce from './useAsyncDebounce'\nimport useFormContext from './useFormContext'\nimport useFieldScope from './useFieldScope'\nimport { getFieldID } from '../utils'\n\nlet uid = 0\n\nconst methodMap = [\n  'setFieldValue',\n  'setFieldMeta',\n  'pushFieldValue',\n  'insertFieldValue',\n  'removeFieldValue',\n  'swapFieldValues',\n]\n\nconst defaultDefaultMeta = {\n  error: null,\n  isTouched: false,\n  isValidating: false,\n}\n\nexport default function useField(\n  fieldName,\n  {\n    defaultValue,\n    defaultIsTouched = false,\n    defaultError = null,\n    defaultMeta = defaultDefaultMeta,\n    validatePristine,\n    validate,\n    filterValue,\n    formContext: manualFormContext,\n  } = {}\n) {\n  if (!fieldName) {\n    throw new Error(\n      `useField: A field is required to use this hook. eg, useField('myField', options)`\n    )\n  }\n\n  const formApiRef = React.useRef()\n  const fieldApiRef = React.useRef({})\n\n  let formApi = useFormContext(manualFormContext)\n\n  const instanceIDRef = React.useRef(uid++)\n  const instanceID = instanceIDRef.current\n\n  // Support field prefixing from FieldScope\n  let fieldPrefix = ''\n  if (formApi.fieldName) {\n    fieldPrefix = `${formApi.fieldName}.`\n    formApi = formApi.form\n  }\n  fieldName = fieldPrefix + fieldName\n\n  // Create a debounce for this field hook instance (not all instances)\n  const debounce = useAsyncDebounce()\n\n  // An escape hatch for accessing latest formAPI\n  formApiRef.current = formApi\n\n  // Get the field value, meta, and metaRef\n  const preValue = formApi.getFieldValue(fieldName)\n  const preMeta = formApi.getFieldMeta(fieldName)\n  const __metaRef = formApi.__getFieldMetaRef(fieldName)\n\n  // Handle default value\n  const value = React.useMemo(\n    () =>\n      typeof preValue === 'undefined' && typeof defaultValue !== 'undefined'\n        ? defaultValue\n        : preValue,\n    [defaultValue, preValue]\n  )\n\n  // Handle default meta\n  const meta = React.useMemo(\n    () =>\n      typeof preMeta === 'undefined'\n        ? {\n            ...defaultMeta,\n            error: defaultError,\n            isTouched: defaultIsTouched,\n          }\n        : preMeta,\n    [defaultError, defaultMeta, defaultIsTouched, preMeta]\n  )\n\n  // Create the fieldApi\n  const fieldApi = React.useMemo(\n    () => ({\n      value,\n      meta,\n      form: formApi,\n      fieldName,\n    }),\n    [fieldName, formApi, meta, value]\n  )\n\n  // Keep the fieldApiRef up to date\n  fieldApiRef.current = fieldApi\n  fieldApiRef.current.__filterValue = filterValue\n  fieldApiRef.current.__validate = validate\n\n  // Let's scope some field-level methods for convenience\n  const [\n    setValue,\n    setMeta,\n    pushValue,\n    insertValue,\n    removeValue,\n    swapValues,\n  ] = methodMap.map(d => {\n    // Since this array is stable and always the same, we can disable\n    // the react-hooks linter here:\n\n    // eslint-disable-next-line\n    return React.useCallback(\n      (...args) => formApiRef.current[d](fieldName, ...args),\n      // eslint-disable-next-line\n      [fieldName]\n    )\n  })\n\n  // Let's scope some field-level methods for convenience\n  const [\n    setFieldValue,\n    setFieldMeta,\n    pushFieldValue,\n    insertFieldValue,\n    removeFieldValue,\n    swapFieldValues,\n  ] = methodMap.map(d => {\n    // Since this array is stable and always the same, we can disable\n    // the react-hooks linter here:\n\n    // eslint-disable-next-line\n    return React.useCallback(\n      (subField, ...args) =>\n        formApiRef.current[d](`${fieldName}.${subField}`, ...args),\n      // eslint-disable-next-line\n      [fieldName]\n    )\n  })\n\n  const runValidation = React.useCallback(async () => {\n    if (!fieldApiRef.current.__validate) {\n      return\n    }\n    setMeta({ isValidating: true })\n\n    // Use the validationCount for all field instances to\n    // track freshness of the validation\n    const id = (__metaRef.current.validationCount || 0) + 1\n    __metaRef.current.validationCount = id\n\n    const checkLatest = () => id === __metaRef.current.validationCount\n\n    if (!__metaRef.current.validationPromise) {\n      __metaRef.current.validationPromise = new Promise((resolve, reject) => {\n        __metaRef.current.validationResolve = resolve\n        __metaRef.current.validationReject = reject\n      })\n    }\n\n    const doValidate = async () => {\n      try {\n        const error = await fieldApiRef.current.__validate(\n          fieldApiRef.current.value,\n          fieldApiRef.current\n        )\n\n        if (checkLatest()) {\n          setMeta({ isValidating: false })\n          if (typeof error !== 'undefined') {\n            if (error) {\n              if (typeof error === 'string') {\n                setMeta({ error })\n              }\n            } else {\n              setMeta({ error: null })\n            }\n          }\n          __metaRef.current.validationResolve()\n        }\n      } catch (error) {\n        if (checkLatest()) {\n          __metaRef.current.validationReject(error)\n          throw error\n        }\n      } finally {\n        if (checkLatest()) {\n          setMeta({ isValidating: false })\n          delete __metaRef.current.validationPromise\n        }\n      }\n    }\n\n    doValidate()\n\n    return __metaRef.current.validationPromise\n  }, [__metaRef, setMeta])\n\n  const getInputProps = React.useCallback(\n    ({ onChange, onBlur, ...rest } = {}) => {\n      return {\n        value,\n        onChange: e => {\n          setValue(e.target.value)\n          if (onChange) {\n            onChange(e)\n          }\n        },\n        onBlur: e => {\n          setMeta({ isTouched: true })\n          if (onBlur) {\n            onBlur(e)\n          }\n        },\n        ...rest,\n      }\n    },\n    [setMeta, setValue, value]\n  )\n\n  const FieldScope = useFieldScope(fieldApi)\n\n  // Fill in the rest of the fieldApi\n  Object.assign(fieldApi, {\n    __metaRef,\n    setValue,\n    setMeta,\n    pushValue,\n    insertValue,\n    removeValue,\n    swapValues,\n    setFieldValue,\n    setFieldMeta,\n    pushFieldValue,\n    insertFieldValue,\n    removeFieldValue,\n    swapFieldValues,\n    debounce,\n    runValidation,\n    getInputProps,\n    FieldScope,\n  })\n\n  React.useEffect(() => {\n    const { current: meta } = formApiRef.current.__getFieldMetaRef(fieldName)\n\n    meta.instanceRefs = meta.instanceRefs || {}\n    meta.instanceRefs[instanceID] = fieldApiRef\n\n    const fieldID = getFieldID(fieldName)\n\n    return () => {\n      delete meta.instanceRefs[instanceID]\n      if (!Object.keys(meta.instanceRefs).length) {\n        fieldApiRef.current.setMeta(() => undefined)\n        delete formApiRef.current.__fieldMetaRefs[fieldID]\n      }\n    }\n  }, [fieldName, instanceID])\n\n  // The default value effect handler\n  React.useEffect(() => {\n    if (typeof preValue === 'undefined' && typeof value !== 'undefined') {\n      setValue(value, { isTouched: false })\n    }\n  }, [preValue, setValue, value])\n\n  // The default meta effect handler\n  React.useEffect(() => {\n    if (typeof preMeta === 'undefined' && typeof meta !== 'undefined') {\n      setMeta(meta)\n    }\n  }, [fieldName, meta, preMeta, setMeta, setValue, value])\n\n  // When the form gets dirty and when the value changes, run the validation\n  React.useEffect(() => {\n    if (!validatePristine && !meta.isTouched) {\n      return\n    }\n\n    try {\n      runValidation(value)\n    } catch (err) {\n      console.error('An error occurred during validation', err)\n    }\n  }, [meta.isTouched, runValidation, validatePristine, value])\n\n  return fieldApiRef.current\n}\n","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n"],"sourceRoot":""}